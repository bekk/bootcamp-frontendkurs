<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Slides - Chat</title>
    <link rel="stylesheet" href="https://cdn.rawgit.com/bekk/remark/master/dist/bekk.css">
    <link rel="stylesheet" href="slides.css">
  </head>
  <body class="bekk-black">
    <textarea id="source">

class: front-page
  # Webutvikling 101
  ## <br>Chatteoppgave<br><br>Mats Kr칲ger Svensson

---
#Introduksjon

Slidesettet ligner de tidligere presentasjonene, med litt teori og etterf칮lgende oppgaver.
Siden det ikke blir felles gjennomgang av oppgavene, forklares l칮sningsforslaget etter hver oppgave.

Eksempel p친 det som skal lages ligger p친 http://bekk-chat.herokuapp.com/
Test det gjerne ut litt s친 du har et klart bilde av hva som skal lages.
Man m친 velge et navn og trykke join for 친 se chatten og kunne chatte. Til h칮yre i bildet
er det en liste over alle brukere som er tilstede. Meldinger vises n친r noen blir med, bytter navn eller forsvinner.
Kan bytte navn ved 친 skrive inn et nytt navn og trykke join.

I denne oppgaven er det selve chatte-klienten som skal lages. Klienten kobles opp mot en felles server slik at
alle deler samme chat.

---
# Kode

I `assignment` mappa, kj칮r de samme kommandoene som tidligere for 친 f친 opp en server:

```bash
npm install
npm start
```

Du kan deretter 친pne klienten ved 친 g친 til http://localhost:5000

Klienten ligger i `assignment/client` mappen og best친r av 3 filer. Dere f친r ferdig oppsatt HTML og CSS, s친 i denne
oppgaven er det i utgangspunktet bare Javascript i `script.js` som skal skrives. Det kan uansett v칝re lurt 친 titte p친 HTML, for 친 vite
hvilke elementer og IDer som kan hentes ut i Javascripten.


---

# DOM APIet - Repetisjon

Kan hente ut elementer vha `queryselector`. `#` foran betyr man henter med id, `.` henter med klasse og ingenting er rett p친 element-type.

```
var el1 = document.querySelector('main'); // matcher <main>
var el2 = document.querySelector('#name'); // matcher <input id="name">
var el3 = document.querySelector('.klasse'); // matcher <div class=".klasse">
```

--

Kan lese ut og endre forskjellige verdier

```
var inputText = el2.value; // henter ut verdien i input-felt
el2.value = 'heihei'; // setter verdien

el2.disabled = true; // disabler input-felt, knapp e.l.

var htmlInnhold = el1.innerHTML; // leser ut html fra et element
el1.innerHTML = '<b>fet skrift</b>'; // setter innholdet til et element
```

---

# Forms og eventlisteners - Repetisjon

Det er forskjellige events man kan lytte p친, f. eks. click p친 elementer eller submit av et form.
Man legger til en funksjon som vil bli kalt n친r et event inntreffer

```
document.querySelector(`#minForm`).addEventListener('submit', function(event) {
    // gj칮r noe ved submit
});
```

Ved submit m친 man kalle `preventDefault` p친 eventet om man ikke vil at nettleseren skal laste siden p친 nytt.

---

# Oppgave 1

* Legg til submit-listener p친 `#nameform`. Den trigges n친r man trykker join-knappen.
* N친r submit trigges, les ut verdien fra navne-inputfeltet og log det til console
* Om navnet ikke er tomt, aktiver `#sendbutton`.

Sjekk at du kan fylle i et navn og trykke join, og at det dukker opp i consolen f칮r du g친r videre.
Sjekk ogs친 at send-knappen blir aktivert etter 친 ha trykket join.

---
class: center middle
# L칮sningsforslag 1

---

.losningsforslag[
```
// henter ut form-elementet og legger til en listener p친 submit
document.querySelector('#nameform').addEventListener('submit', function (event) {
    // hindrer refresh av siden
    event.preventDefault();

    // henter ut inputfeltet for navn og leser ut verdien
    var name = document.querySelector('#name').value;
    console.log(name);

    if (name !== '') { // om navn ikke tomt
        // hent ut send-knappen og sett disabled til false
        document.querySelector('#sendbutton').disabled = false;
    }
});
```]

---

# WebSockets Intro

Vi har brukt `fetch` for 친 s칮ke etter bilder tidligere. Det 친 kalle fetch f칮rte til en http-request til en server,
som s친 svarte med en liste over bilder. Http fungerer alltid p친 denne m친ten, ved at klienten gj칮r et kall mot serveren og f친r data tilbake.
Serveren kan aldri sende data til klienten uten at klienten har sendt en request f칮rst.

Skal man lage en chat, er dette ikke helt optimalt. Eneste m친ten 친 f친 nye meldinger p친 er 친 sende en request til serveren, s친 for 친 f친 til en
chat der nye meldinger dukker opp med en gang, m친 man regelrett spamme serveren med requests. Er det mange brukere som gj칮r dette samtidig vil
serveren fort krasje.

Websockets, derimot, er en toveis protokoll. Etter at en tilkobling er opprettet kan b친de klient og server sende data til hverandre n친r de 칮nsker.
Det gir mulighet for real-time applikasjoner som chat, spill osv.

---

# WebSockets API

For 친 opprette en WebSocket-tilkobling, m친 man sende inn URLen til serveren man vil koble seg til.
Merk at det brukes `ws` i URLen i stedet for `http`.

```
var websocket = new WebSocket('ws://bekk-chat.herokuapp.com');
```

--

For 친 sende meldinger, kaller man `send` p친 websocket-objektet.

```
websocket.send('hei, hei');
```

--

For 친 lytte p친 meldinger legger man til en funksjon som kalles hver gang websocketen f친r en melding fra serveren.
Denne funksjonen f친r inn et event, og dataen fra serveren ligger p친 `.data` p친 dette eventet.

```
websocket.onmessage = function(event) {
    console.log(event.data);
}
```

---

# JSON

Websockets kan bare sende tekst frem og tilbake, mens man trenger ofte 친 sende mer avansert data.
For 친 gj칮re det kan man bruke JSON. JSON er et tekst-format som er lett 친 konvertere til og fra javascript-objekter.

`JSON.stringify` konverterer et javascript-objekt om til JSON-tekst

```
var objekt = {
    id: 33,
    navn: 'Mats'
}
var tekst = JSON.stringify(objekt);
// gir '{"id": 33, "navn": "Mats"}' som en tekststreng
```

Tilsvarende kan man konvertere tekst tilbake til javascript-objekt med `JSON.parse`

```
var tekst2 = '{"id":99,"navn":"Kent"}';
var objekt2 = JSON.parse(tekst2);
// kan n친 kalle objekt2.id og objekt2.navn
```
---

# JOINE-protokoll

For 친 bli med i chatten krever serveren at man har sagt hva man vil hete. Serveren forventer JSON-tekst som den
kan konvertere til et objekt p친 formen

```
{
    type: 'name',
    name: 'Mats'
}
```

Siden det skal sendes mye forskjellig data frem og tilbake etterhvert, har vi et type-felt som sier hva slags data det er.
For 친 sette navn, skal typen v칝re `name`. I tillegg m친 man sende med navnet man vil ha.

---

#Oppgave 2

* I toppen av javascriptfilen, opprett en websocket-tilkobling til chatte-serveren
 * Den ligger p친 URL `ws://bekk-chat.herokuapp.com`
* Inne i eventlisteneren fra forrige oppgave (n친r brukeren har trykket join), send det valgte navnet til serveren via websocketen.
 * Objektet m친 v칝re p친 formen fra forrige slide
 * Huske 친 gj칮re objektet om til en tekst-streng f칮r det sendes

Sjekk p친 http://bekk-chat.herokuapp.com/ at brukeren har joinet riktig.

---
class: center middle
# L칮sningsforslag 2

Ny kode p친 formen

```
// gammel linje
*// ny linje
*// ny linje
// gammel linje
```

---

.losningsforslag[
```
*// oppretter en websocket-tilkobling til riktig url
*var websocket = new WebSocket('ws://bekk-chat.herokuapp.com');

document.querySelector('#nameform').addEventListener('submit', function (event) {
    event.preventDefault();

    var name = document.querySelector('#name').value;

    if (name !== '') {
*       // lag et objekt p친 riktig form og med valgt navn
*       var data = {
*           type: 'name',
*           name: name
*       };
*       // gj칮r det om til en tekststreng
*       var dataString = JSON.stringify(data);
*       // send tekststrengen via websocket
*       websocket.send(dataString);

        document.querySelector('#sendbutton').disabled = false;
    }
});
```]

---

# Oppgave 3

* Legg til en funksjon p친 websocketen sin `onmessage` som beskrevet tidligere.
* I denne funksjonen, les ut data fra eventet og konverter det fra JSON til et objekt
* Log dette objektet til console

Om alt har g친tt riktig, skal man n친 i det man trykker join f친 tilsendt litt data fra serveren.
I console kan du se hva du mottar.


---
class: center middle
# L칮sningsforslag 3

Her m친 du kanskje scrolle litt

---

.losningsforslag[
```
var websocket = new WebSocket('ws://bekk-chat.herokuapp.com');

document.querySelector('#nameform').addEventListener('submit', function (event) {
    event.preventDefault();

    var name = document.querySelector('#name').value;

    if (name !== '') {
        var data = {
            type: 'name',
            name: name
        };

        var dataString = JSON.stringify(data);
        websocket.send(dataString);

        document.querySelector('#sendbutton').disabled = false;
    }
});

*// Legger til en funksjon p친 onmessage
*websocket.onmessage = function(event) {
*   // Leser ut data fra eventet og konverterer det til et objekt
*   var data = JSON.parse(event.data);
*   // Logger det vi mottar til console
*   console.log(data);
}
```]
---

# Template String - Repetisjon

Bruker `backticks` (shift + knappen f칮r backspace), gj칮r at man kan fylle inn verdier med `${variabelnavn}`.

```javascript
var img = {
    url: "http://flickr.com/bilde.jpg",
    title: "Kult bilde"
};

var html = `
    <figure>
        <img src="${img.url}" />
        <figcaption>${img.title}</figcaption>
    </figure>
        `;
```

---

# Meldinger - Protokoll

Som man kan se i console fra forrige oppgave, f친r man et objekt med type `messages` i det en bruker joiner.
Dette objektet inneholder en liste over meldinger som har kommet f칮r brukeren joinet, med den nyeste til slutt.

```json
{
  "type": "messages",
  "messages": [{
      "name": "MM",
      "message": "asdas",
      "time": "2016-04-05T14:13:56.149Z"
    }, {
      "name": "Mats",
      "message": "Hei",
      "time": "2016-04-05T14:14:57.723Z"
    },{
      "name": "Kent",
      "message": "Hei, hei",
      "time": "2016-04-05T14:15:06.382Z"
    }]
}
```

---




# Meldinger - Protokoll 2

N친r en bruker sender en ny melding i chaten, kommer det fra serveren p친 denne formen. Merk forskjell p친 type fra
forrige slide (message vs messages)

```
{
  "type": "message",
  "name": "sd",
  "message": "asdasd",
  "time": "2016-04-05T16:30:56.907Z"
}
```

---

# Meldinger HTML

Den medf칮lgende CSSen forventer at meldinger blir gjort om til HTML med f칮lgende struktur:

```html
<div class="message">
    <span class="name">Navn p친 avsender</span>
    <span class="time">tidspunkt</span>
    <span class="text">innhold</span>
</div>
```


---

# Oppgave 4

* Lag en funksjon `renderMessage` som tar inn en melding og lager HTML for 친 vise denne  (se eksempel p친 forrige slide) 칮verst i `#messages`-elementet
* I `onmessage` funksjonen, sjekk om typen er av `messages`. Hvis det er tilfelle, send hver melding inn til funksjonen du nettopp lagde.
* Om typen er av `message`, skal den ogs친 sendes til `renderMessage`.

Om alt har g친tt riktig, skal man i det man trykker join n친 se de siste meldingene. Tidspunktet kan
kanskje v칝re litt feil og stygt, det fikser vi senere.

Nye meldinger skal ogs친 dukke opp fortl칮pende, g친 til http://bekk-chat.herokuapp.com/ og send noen meldinger
der og sjekk om de dukker opp i din klient.


---
class: center middle
# L칮sningsforslag 4
---

.losningsforslag[
```
var websocket = new WebSocket('ws://bekk-chat.herokuapp.com');

document.querySelector('#nameform').addEventListener('submit', function (event) {
    event.preventDefault();

    var name = document.querySelector('#name').value;

    if (name !== '') {
        var data = {
            type: 'name',
            name: name
        };
        var dataString = JSON.stringify(data);
        websocket.send(dataString);

        document.querySelector('#sendbutton').disabled = false;
    }
});

websocket.onmessage = function(event) {
    var data = JSON.parse(event.data);
    console.log(data);

*   // sjekker typen
*   if (data.type === 'messages') {
*       // henter meldingene fra data
*       var messages = data.messages;
*
*       // iterer over hver melding med en for-l칮kke og rendrer den
*       for (var i = 0; i < messages.length; i++) {
*           var singleMessage = messages[i];
*           renderMessage(singleMessage);
*       }
*   } else if (data.type === 'message') {
*       // om det var en enkelt melding rendrer vi den bare
*       renderMessage(data);
*   }
};

*function renderMessage(message) {
*   // henter ut elementet
*   var messageElement = document.querySelector('#messages');
*
*   // lager HTMLen for en melding
*   var messageHtml = `
*       <div class="message">
*           <span class="name">${message.name}</span>
*           <span class="time">${message.time}</span>
*           <span class="text">${message.message}</span>
*       </div>
*   `;
*
*   // Setter innholdet i elementet til 친 v칝re meldingen pluss hva enn det var f칮r
*   messageElement.innerHTML = messageHtml + messageElement.innerHTML;
*}
```]

---

# Meldinger - Protokoll 3

For 친 sende en melding til serveren skal objektet se slik ut:

```
{
    type: 'message',
    message: 'Min melding'
}
```

Serveren legger selv p친 tidspunkt og hvem som sendte meldingen f칮r den s친 sender meldingen videre
til alle som er koblet p친 chaten (inkludert den som sendte meldingen).


---

#Oppgave 5

* Legg til en submit-listener p친 meldinger-formet
* N친r denne trigges, send meldingen brukeren skrev inn til serveren og nullstill teksten i tekstfeltet



---
class: center middle
# L칮sningsforslag 5
---

.losningsforslag[
```
// resten av koden er lik, men n친 med dette i bunn:

// legger p친 submit-listener p친 formet
document.querySelector('#sendform').addEventListener('submit', function (event) {
    // hindrer refresh
    event.preventDefault();

    // henter ut input-elementet der brukeren skriver meldingen
    var sendmessageInput = document.querySelector("#sendmessage");
    // henter ut verdien
    var message = sendmessageInput.value;
    // nullstiller feltet
    sendmessageInput.value = ''; // reset

    // lager objektet, gj칮r det om til JSON og sender det, alt i samme slengen
    websocket.send(JSON.stringify({
        type: 'message',
        message: message
    }));
});
```]

---


# Brukere - Protokoll

N친r brukere joiner, forsvinner eller bytter navn blir det sendt data fra serveren til alle klienter.
Denne dataen er av typen `users`, og inneholder en liste over navn p친 brukere som er tilkoblet.
I tillegg er det en action som sier hva som har skjedd, og litt forskjellig data avhengig av hva som skjedde.

```
{
    type: 'users',
    users: ['Mats', 'Kent', 'Ingvild'],
    ...
}
```
---


# Brukere Join - Protokoll

N친r en bruker joiner f친r man med navnet p친 den nye brukeren

```
{
    type: 'users',
    users: ['Mats', 'Kent', 'Ingvild'],
    action: 'joined',
    name: 'Mats'
}
```
---


# Brukere Forsvinner - Protokoll

N친r en bruker forsvinner f친r man navnet p친 hvem som forsvant

```
{
    type: 'users',
    users: ['Kent', 'Ingvild'],
    action: 'left',
    name: 'Mats'
}
```
---


# Brukere Endret Navn - Protokoll

Om en bruker har byttet navn f친r man nytt og gammelt navn

```
{
    type: 'users',
    users: ['Mats2', 'Kent', 'Ingvild'],
    action: 'renamed',
    name: 'Mats2',
    oldname: 'Mats'
}
```

---

# Oppgave 6

* N친r det kommer data av typen `users` fra serveren, hent ut navnene til de p친loggede brukerne og vis dem i `#users`-elementet
 * For 친 f친 riktig styling, legg til HTML p친 formen `<span class="name">Navn</span>` for hver bruker

Skal n친 kunne se hvem som er tilstede. 칀pne flere vinduer og join og lukk vinduer og sjekk at listen over brukere endres.


---
class: center middle
# L칮sningsforslag 6

---


.losningsforslag[
```
// endret litt inni her
websocket.onmessage = function(event) {
    var data = JSON.parse(event.data);
    console.log(data);

    if (data.type === 'messages') {
        var messages = data.messages;
        for (var i = 0; i < messages.length; i++) {
            var singleMessage = messages[i];
            renderMessage(singleMessage);
        }
    } else if (data.type === 'message') {
        renderMessage(data);
*   } else if (data.type === 'users') {
*       // kaller funksjonen med de aktive brukerne
*       renderActiveUsers(data.users);
*   }
};

*function renderActiveUsers(activeUsers) {
*   // henter elementet vi vil putte navnene i
*   var usersElement = document.querySelector('#users');
*
*   var html = '';
*
*   // itererer over alle navnene og lager en stor html-string
*   for (var i = 0; i < activeUsers.length; i++) {
*       var name = activeUsers[i];
*       html += `
*           <span class="name">${name}</span>
*       `;
*   }
*
*   // setter innholdet til elementet til 친 v칝re html vi har laget
*   usersElement.innerHTML = html;
*}

// resten av koden er lik
```]

---

# Oppgave 7

* Sjekk hvilken action det er n친r det kommer inn data av typen `users` og vis en passende melding i chaten.
 * Blir stylet riktig om HTMLen er p친 formen `<div class="connection">Melding</div>`

F. eks. kan det n친r en bruker joiner komme en melding om "Mats har joinet",
eller om det var navnebytte "Mats har byttet navn til Mats2".


---
class: center middle
# L칮sningsforslag 7

---

.losningsforslag[
```
// endret litt inni her
websocket.onmessage = function(event) {
    var data = JSON.parse(event.data);
    console.log(data);

    if (data.type === 'messages') {
        var messages = data.messages;
        for (var i = 0; i < messages.length; i++) {
            var singleMessage = messages[i];
            renderMessage(singleMessage);
        }
    } else if (data.type === 'message') {
        renderMessage(data);
    } else if (data.type === 'users') {
        renderActiveUsers(data.users);

*       // Kall v친r nye funksjon
*       showConnectionMessage(data);
    }
};

*function showConnectionMessage(data) {
*   var message;
*
*   // Sjekker hvilken action det var, og lager forskjellige beskjeder
*   if (data.action === 'joined') {
*       message = `${data.name} has joined`;
*   } else if (data.action === 'left') {
*       message = `${data.name} has left`;
*   } else if (data.action === 'renamed') {
*       message = `${data.oldname} has changed name to ${data.name}`;
*   }
*
*   // Legger beskjeden inni litt HTML for stylingens skyld
*   var html = `<div class="connection">${message}</div>`;
*
*   // Henter ut elementet og legger det nye innholdet inn i tillegg til hva enn som var der fra f칮r
*   var messageElement = document.querySelector('#messages');
*   messageElement.innerHTML = html + messageElement.innerHTML;
*}

// Resten er likt som f칮r
```]

---

# Datoer i Javascript

Datoene s친 langt er p친 formen `2016-04-05T19:34:54.406Z`, noe som ikke er veldig pent og troligvis feil med noen timer.
Z-en bakerst betyr at det er i UTC-tidssone, mens det mest logiske er 친 vise det i riktig tid for brukeren.

Javascript har innebygd st칮tte for datoer, via `Date`-klassen. Om man sender inn en dato-tekststreng p친 formen over, vil nettleseren
automatisk kovertere den til tidssonen til brukeren. Om man ikke sender inn noen ting f친r man datoen/tidspunktet
her og n친. [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) har info om mange funksjoner som
kan kalles p친 date-objekter.

```
var date1 = new Date(); // her og n친
var date2 = new Date('2016-04-05T19:34:54.406Z'); // fra et spesifikt tidspunkt

date2.getFullYear();
date2.getMinutes();
// osv.
```

---

# Oppgave 8

* Gj칮r slik at tidspunktene p친 meldinger er p친 formen hh:mm:ss, f. eks. 19:46:06


---
class: center middle
# L칮sningsforslag 8

---

.losningsforslag[
```
function renderMessage(message) {
*   // lager et dato-objekt utifra dato-teksten
*   var time = new Date(message.time);
*   // leser ut de forskjellige verdiene vi 칮nsker
*   var hour = time.getHours();
*   var minutes = time.getMinutes();
*   var seconds = time.getSeconds();
*
*   // siden getHours f. eks. kan returnere 7, slenger
*   // vi p친 en 0 foran slik at det st친r 07
*   if (hour < 10) {
*       hour = '0' + hour;
*   }
*   if (minutes < 10) {
*       minutes = '0' + minutes;
*   }
*   if (seconds < 10) {
*       seconds = '0' + seconds;
*   }

    var messageElement = document.querySelector('#messages');

*   // bruker de nye verdiene for 친 vise tidspunkt
    var messageHtml = `
        <div class="message">
            <span class="name">${message.name}</span>
*           <span class="time">${hour}:${minutes}:${seconds}</span>
            <span class="text">${message.message}</span>
        </div>
    `;

    messageElement.innerHTML = messageHtml + messageElement.innerHTML;
}

// Resten er likt som f칮r
```]

---
# Litt 친 tenke p친: Sikkerhet

I denne oppgaven har vi tatt beskjeder fra andre brukere og puttet rett i HTMLen, kan du se hvorfor det kan v칝re farlig?

--

Om brukeren sendte en beskjed med innholdet: `<b>Hei</b> p친 deg`<br>
og vi dytter den rett inn i HTMLen, vil HTMLen faktisk tolkes og noe av skriften bli fet.

Det er kanskje ikke s친 farlig, men hva om man skriver: `<script>alert('WARNING');</script>`<br>
s친 kj칮res faktisk den koden ogs친 n친r den dyttes inn i HTMLen! S친 da kan ondsinnede brukere faktisk sende kode
via chat som vil kj칮res p친 andres maskiner. Dette er et typisk "XSS"-angrep.

Denne hackingen vil ikke fungere her (forh친pentligvis), da chatte-serveren tar hensyn til dette.
Men det er noe 친 v칝re obs p친, aldri stol p친 brukerdata, det m친 "vaskes" f칮r det vises p친 siden.

---

class: center middle

#Videre oppgaver

## Gj칮res i valgfri rekkef칮lge

---

# 1: Layout

* F친 chatten til 친 se mere ut som Slack eller tilsvarende chatte-applikasjoner. Alts친:
 * Nye meldinger kommer nederst, uten at brukeren m친 scrolle ned hele tiden
 * Meldings-inputen ligger i bunn av siden
 * Layouten fungerer selv om man justerer h칮yden/bredden p친 vinduet


---

# 2: Emoji-tastatur

* Legg til en knapp, som n친r trykkes p친 친pner/lukker en boks som ligger absolutt posisjonert
* Denne boksen inneholder smileyer (enten :) ;) osv. evt. unicode som 游녨游녥游눩)
* N친r man trykker p친 en smiley, blir den satt inn bakerst i teksten.
* Utvid funksjonaliteten, slik at smileyen blir satt inn der man sist hadde mark칮ren (den blinkende |) i tekstfeltet
* Pr칮v 친 posisjonere knappen som 친pner smiley-boksen over input-feltet, som p친 Slack

## Tips
* [Classlist](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList) p친 et DOM-element lar en legge til/fjerne
klasser, nyttig for 친 skjule/vise ting
* Kan lese ut mark칮r-posisjonen vha `selectionStart` p친 et input-element.


---

# 3: Antall uleste

<img src="uleste.png" />

* N친r brukeren ikke har chatte-fanen synlig, vis i fane-tittelen om det er uleste meldinger
* Endre tilbake til original tittel n친r fanen blir aktiv


* Tips: window.onblur, window.onfocus, document.title

---

# 4: Favicon / notifications
(gj칮r nr 3 f칮rst)

<img src="favicon.png" />

* Lag et favicon med nettsiden under, navngi det favicon-normal.ico og legg det i client mappen
* Legg til html-snutten under i head-delen av htmlen, da skal du se iconet i nettleseren
* Lag et nytt ikon som blir vist ved uleste meldinger
* Lag enda et ikon, som vises om en av de uleste meldingene inneholdt navnet du joinet med

## Tips
 * http://www.favicon.cc/ for 친 lage ikoner
 * `<link rel="shortcut icon" href="favicon-normal.ico" type="image/x-icon" id="icon"/>`
 * Da kan du hente ut favicon-elementet vha id, og endre href-verdien til et annet ikon

---

# 5: Fritt vilt

* Noe annet du synes appen trenger?

---

# Backend

* Er du interessert i 친 se hvordan serveren er laget, kan du [se her](https://github.com/Matsemann/ws-chat).
Sjekk ut index.js filen og chat.js. Det meste ligner, bortsett fra at APIet for websockets er litt annerledes enn
i en nettleser, og vi her m친 holde styr p친 flere tilkoblinger samtidig.




    </textarea>
    <script src="https://cdn.rawgit.com/bekk/remark/master/vendor/remark.min.js" type="text/javascript"></script>
    <script type="text/javascript">
      'use strict';
      var slideshow = remark.create({
        ratio: '16:9',
        highlightLanguage: 'javascript',
        highlightStyle: 'monokai',
        navigation: {
          scroll: false
        },
          highlightLines: true
      });

    </script>
  </body>
</html>
